The virtual machine takes bytecode generated by the front-end as instructions. It can then perform operations on one or more tables or indexes, each of which is stored in a data structure called a B-tree. The VM is essentially a big switch statement on the type of bytecode instruction.

Each B-tree consists of many nodes. Each node is one page in length. The B-tree can retrieve a page from disk or save it back to disk by issuing commands to the pager.

The pager receives commands to read or write pages of data. It is responsible for reading/writing at appropriate offsets in the database file. It also keeps a cache of recently-accessed pages in memory, and determines when those pages need to be written back to disk.

The os interface is the layer that differs depending on which operating system sqlite was compiled for. In this tutorial, I’m not going to support multiple platforms.


## Getline
`ssize_t getline(char **lineptr, size_t *n, FILE *stream);

- lineptr : a pointer to the variable we use to point to the buffer containing the read line. If it set to NULL it is mallocatted by getline and should thus be freed by the user, even if the command fails.
- n : a pointer to the variable we use to save the size of allocated buffer.
- stream : the input stream to read from. We’ll be reading from standard input.
- return value : the number of bytes read, which may be less than the size of the buffer


Non-SQL statements like .exit are called “meta-commands”. They all start with a dot, so we check for them and handle them in a separate function.

column	    type
id	        integer
username	varchar(32)
email	    varchar(255)

## insert 
insert 1 cstack foo@bar.com




column	size (bytes)	offset
id	        4	0
username	32	4
email	255	36
total	291



page   = n / ROWS_PER_PAGE
offset = n % ROWS_PER_PAGE

Avec n = 40 et ROWS_PER_PAGE = 40
page   = 40 / 40 = 1
offset = 40 % 40 = 0

Interprétation
page 1 : oui
offset 0 : première ligne de cette page

## L’offset = l’index de la ligne à l’intérieur de la page.

- row_slot: It maps a logical row number to a physical address
(page_id, byte_offset) → memory pointer



## Pager
We ask the pager for page number x, and the pager gives us back a block of memory. It first looks in its cache. On a cache miss, it copies data from disk into memory (by reading the database file).


In our current design, the length of the file encodes how many rows are in the database, so we need to write a partial page at the end of the file. That’s why pager_flush() takes both a page number and a size. It’s not the greatest design

The first four bytes are the id of the first row (4 bytes because we store a uint32_t). It’s stored in little-endian byte order, so the least significant byte comes first (01), followed by the higher-order bytes (00 00 00). We used memcpy() to copy bytes from our Row struct into the page cache, so that means the struct was laid out in memory in little-endian byte order. That’s an attribute of the machine I compiled the program for. If we wanted to write a database file on my machine, then read it on a big-endian machine, we’d have to change our serialize_row() and deserialize_row() methods to always store and read bytes in the same order.

The next 33 bytes store the username as a null-terminated string. Apparently “cstack” in ASCII hexadecimal is 63 73 74 61 63 6b, followed by a null character (00). The rest of the 33 bytes are unused.

The next 256 bytes store the email in the same way


If we wanted to ensure that all bytes are initialized, it would suffice to use strncpy instead of memcpy while copying the username and email fields of rows in serialize_row


## Cursor
Cursor object which represents a location in the table. Things you might want to do with cursors:

- Create a cursor at the beginning of the table
- Create a cursor at the end of the table
- Access the row the cursor is pointing to
- Advance the cursor to the next row

## tree structure 
each node in the tree can contain a variable number of rows, we store in each node some info to keep track of how many rows it contains. 

| Aspect           | Unsorted Array of rows | Sorted Array of rows | Tree of nodes |
|------------------|------------------------|----------------------|---------------|
| Pages contain    | only data              | only data            | metadata, primary keys, and data |
| Rows per page    | more                   | more                 | fewer         |
| Insertion        | O(1)                   | O(n)                 | O(log n)      |
| Deletion         | O(n)                   | O(n)                 | O(log n)      |
| Lookup by id     | O(n)                   | O(log n)             | O(log n)      |

- one node = one page 

- Internal nodes will point to their children by storing the page number that stores the child 
- The btree asks the pager for a particular page number and gets back a pointer into the page cache.
- Pages are stored in the database file one after the other in order of page number.
- Nodes need to store some metadata in a header at the beginning of the page. Every node will store what type of node it is, whether or not it is the root node, and a pointer to its parent (to allow finding a node’s siblings)

┌─────────────────────────────────┐
│  EN-TÊTE COMMUN (6 octets)      │
├──────────┬──────────┬───────────┤
│ Type     │ Est      │ Pointeur  │
│ (1 oct)  │ racine?  │ parent    │
│          │ (1 oct)  │ (4 oct)   │
└──────────┴──────────┴───────────┘
   ↑          ↑          ↑
Position 0  Position 1  Position 2

- **NUM_CELLS** (4 octets) : Combien de données sont stockées dans cette feuille ?
L'en-tête total d'une feuille = 6 octets (commun) + 4 octets (spécifique) = **10 octets**


## CELL (donnee dans une feuille)

Une CELLULE = 1 donnée stockée. Chaque cellule contient 2 parties :
1. (KEY) (4 octets) : Un numéro unique pour identifier la donnée (comme un ID)
2. (VALUE) (ROW_SIZE octets) : La donnée elle-même (par exemple : nom, prénom, email d'une personne)

┌─────────────┬──────────────────────────────┐
│   CLÉ       │        VALEUR                │
│  (4 oct)    │      (ROW_SIZE octets)       │
│             │                              │
│   123       │  "Jean Dupont, 30 ans, ..."  │
└─────────────┴──────────────────────────────┘

Une PAGE = un bloc de mémoire de taille fixe (par exemple 4096 octets).
1. **Espace disponible** = Taille totale de la page - Taille de l'en-tête
2. **Nombre max de cellules** = Espace disponible ÷ Taille d'une cellule

┌─────────────────────────────────────────────┐
│           UNE PAGE (ex: 4096 octets)        │
├─────────────────────────────────────────────┤
│  EN-TÊTE (10 octets)                        │
│  ┌────────────────────────────────────────┐ │
│  │ Type│Racine│Parent│Nb cellules         │ │
│  └────────────────────────────────────────┘ │
├─────────────────────────────────────────────┤
│  CELLULE 1 │ Clé: 1  │ Valeur: ...        │ │
├─────────────────────────────────────────────┤
│  CELLULE 2 │ Clé: 5  │ Valeur: ...        │ │
├─────────────────────────────────────────────┤
│  CELLULE 3 │ Clé: 7  │ Valeur: ...        │ │
├─────────────────────────────────────────────┤
│  ...                                        │
│  (jusqu'à LEAF_NODE_MAX_CELLS)              │
└─────────────────────────────────────────────┘

Exemple de calcul :
Si PAGE_SIZE = 4096 octets et CELL_SIZE = 104 octets :

Espace pour cellules = 4096 - 10 = 4086 octets
Nombre max de cellules = 4086 ÷ 104 = 39 cellules

┌─────────────────────────────────────────────────────────────────┐
│                    PAGE #1 (4096 octets)                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ╔═══════════════════════════════════════════════════════════╗ │
│  ║           EN-TÊTE COMMUN (6 octets)                       ║ │
│  ╠═══════════════╦═══════════════╦═══════════════════════════╣ │
│  ║ NODE_TYPE     ║ IS_ROOT       ║ PARENT_POINTER            ║ │
│  ║ 1 octet       ║ 1 octet       ║ 4 octets                  ║ │
│  ║               ║               ║                           ║ │
│  ║ Valeur: 1     ║ Valeur: 1     ║ Valeur: 0                 ║ │
│  ║ (LEAF)        ║ (OUI, racine) ║ (pas de parent)           ║ │
│  ╚═══════════════╩═══════════════╩═══════════════════════════╝ │
│                                                                 │
│  ╔═══════════════════════════════════════════════════════════╗ │
│  ║        EN-TÊTE SPÉCIFIQUE FEUILLE (4 octets)              ║ │
│  ╠═══════════════════════════════════════════════════════════╣ │
│  ║ LEAF_NODE_NUM_CELLS                                       ║ │
│  ║ 4 octets                                                  ║ │
│  ║                                                           ║ │
│  ║ Valeur: 3  (il y a 3 utilisateurs stockés)               ║ │
│  ╚═══════════════════════════════════════════════════════════╝ │
│                                                                 │
│         [FIN DE L'EN-TÊTE : 10 octets utilisés]                │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                        CELLULES (DONNÉES)                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │ CELLULE 1 (295 octets)                                    │ │
│  ├─────────────┬─────────────────────────────────────────────┤ │
│  │ CLÉ         │ VALEUR (ROW)                                │ │
│  │ 4 octets    │ 291 octets                                  │ │
│  ├─────────────┼─────────────────────────────────────────────┤ │
│  │ 1           │ id: 1                                       │ │
│  │             │ username: "alice"                           │ │
│  │             │ email: "alice@example.com"                  │ │
│  └─────────────┴─────────────────────────────────────────────┘ │
│                                                                 │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │ CELLULE 2 (295 octets)                                    │ │
│  ├─────────────┬─────────────────────────────────────────────┤ │
│  │ CLÉ         │ VALEUR (ROW)                                │ │
│  │ 4 octets    │ 291 octets                                  │ │
│  ├─────────────┼─────────────────────────────────────────────┤ │
│  │ 5           │ id: 5                                       │ │
│  │             │ username: "bob"                             │ │
│  │             │ email: "bob@example.com"                    │ │
│  └─────────────┴─────────────────────────────────────────────┘ │
│                                                                 │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │ CELLULE 3 (295 octets)                                    │ │
│  ├─────────────┬─────────────────────────────────────────────┤ │
│  │ CLÉ         │ VALEUR (ROW)                                │ │
│  │ 4 octets    │ 291 octets                                  │ │
│  ├─────────────┼─────────────────────────────────────────────┤ │
│  │ 12          │ id: 12                                      │ │
│  │             │ username: "charlie"                         │ │
│  │             │ email: "charlie@example.com"                │ │
│  └─────────────┴─────────────────────────────────────────────┘ │
│                                                                 │
│  [ESPACE LIBRE : 3201 octets restants pour futures cellules]   │
│                                                                 │
│  Capacité maximale : (4096 - 10) ÷ 295 = 13 cellules max       │
│  Actuellement utilisées : 3 cellules                            │
│  Espace utilisé : 10 + (3 × 295) = 895 octets                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘


(PAGE_SIZE - HEADER_SIZE) / CELL_SIZE



## Methods

### leaf_node_num_cells
Cette fonction donne l’addresse en mémoire où est stocké le nombre de cellules dans une feuille.

node = début de la page (ex: 0x1000)
LEAF_NODE_NUM_CELLS_OFFSET = 6

offset 0..5   → header commun
offset 6..9   → num_cells (uint32_t)
uint32_t *num = leaf_node_num_cells(node);
*num = 2;
On va à node + 6
On écrit 2
La feuille contient maintenant 2 cellules


### leaf_node_cell
Cette fonction donne l’adresse mémoire de la cellule numéro cell_num dans la feuille.

node = début de la page
LEAF_NODE_HEADER_SIZE = 10
LEAF_NODE_CELL_SIZE = taille d’une cellule

[ header (10 bytes) ][ cell 0 ][ cell 1 ][ cell 2 ] ...
void *cell0 = leaf_node_cell(node, 0);
void *cell1 = leaf_node_cell(node, 1);

### leaf_node_key
adresse de la key de la cellule cell_num

[ key (4 bytes) ][ value (ROW_SIZE bytes) ]
uint32_t *key = leaf_node_key(node, 0);
*key = 10;
On va à l’adresse de la cellule 0
On écrit 10 dans les 4 premiers octets

cell 0:
[ 10 ][ valeur... ]

### leaf_node_value
l’adresse de la valeur (la ligne) associée à une clé.
juste apres key 
[ key (4 bytes) ][ value (ROW_SIZE bytes) ]

On va à la cellule 0
On saute 4 octets (la clé)
On écrit "Alice" dans la zone valeur

```
char *value = leaf_node_value(node, 0);
memcpy(value, "Alice", 6);
```
clé → offset 0
valeur → offset +4

cell 0:
[ key ][ 'A' 'l' 'i' 'c' 'e' 0 ... ]




## Splitting the node 
Root 
Internal 
Leaf

{5: 'a', 12: 'b'}


            * , 5, *
{1: "c", 5: "a"}    {12: "b"}

If there is no space on the leaf node, we would split the existing entries residing there and the new one (being inserted) into two equal halves: lower and upper halves. (Keys on the upper half are strictly greater than those on the lower half.) We allocate a new leaf node, and move the upper half into the new node.

## Creating a new root
Let N be the root node. First allocate two nodes, say L and R. Move lower half of N into L and the upper half into R. Now N is empty. Add 〈L, K,R〉 in N, where K is the max key in L. Page N remains the root. Note that the depth of the tree has increased by one, but the new tree remains height balanced without violating any B+-tree property.


# internal node layers	max # leaf nodes	Size of all leaf nodes
0	511^0 = 1	            4 KB
1	511^1 = 512	            ~2 MB
2	511^2 = 261,121	        ~1 GB
3	511^3 = 133,432,831	    ~550 GB

In actuality, we can’t store a full 4 KB of data per leaf node due to the overhead of the header, keys, and wasted space. But we can search through something like 500 GB of data by loading only 4 pages from disk. This is why the B-Tree is a useful data structure for databases.
